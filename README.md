# Construction-of-a-Trie

1 Problem
Let S be a set of strings. For a given string x, we want to find a string in S that has the longest prefix matching with x. Here we restrict strings to bit strings. As an example, if x = 001100 is looked up in a given set S = {001010, 000111, 111000, 010000, 110001}, the string of interest is 001010. This problem is known as the longest prefix match (LPM) problem. In fact LPM has a wide range of applications in computer science including IP address lookup in routers, data compressions, coding, hashing, and so on. In this lab, we are going to implement an efficient data structure for LPM called a trie.
A binary trie (from retrieval), or simply trie, is a variant of the binary search tree that stores (binary) strings. Unlike the binary trees considered in the lecture, data will be stored in a leaf of the trie. The above diagram shows a trie containing five strings, where circles and rectangles represent internal nodes and leaf nodes, respectively. Hereafter we assume that all strings to be stored in a trie and checked against the trie are of the same length.
1.1 Construction of a Trie
The trie over S is built as follows. For |S| = 0, the trie is empty. For |S| = 1, the trie is a single leaf. Now assume that the trie contains at least one string. To insert a new string x to the trie, we first need to locate a proper place to insert x. The search starts from the root and chooses either left or right child depending on the ith bit xi of x, where i = 0,1,2,...; left child if xi = 0 and right if xi = 1. For example, if x = 110... then search
 1
chooses right, right, left, and so on. The search continues until it ends up with either a leaf or an empty node 1. For the latter, the empty node is replaced by a new node containing new string x. In the other case where a leaf is found at the end of the search path, the path extends further down the trie. To do this, let y = y0y1y2... be the string stored in the leaf node. Now the leaf splits further by creating one or more internal nodes until both x and y can be inserted to the trie. i.e. until the first index i such that xi ̸= yi is found. Observe that all strings are stored in leaf nodes while internal nodes are branching nodes used to direct strings to their destinations (i.e. leaf nodes). The figure below illustrates how a trie grows as strings are inserted in the order 001010, 000111, 111000, 010000, and 110001. A newly inserted string is indicated by a rectangle with a thick outline in each figure.
height = 0, size = 0 height = 1, size = 1 height = 4, size = 2
      height = 4, size = 3 height = 4, size = 4
1.2 Search for a Longest Prefix Match
height = 4, size = 5
The search method, search(T, x) takes a non-empty trie T and string x, and returns a string stored in T that has a longest prefix match with x. If the search ends up with a leaf, the string in the node is the longest prefix match to be returned. On the other hand, if the search runs into an empty node, there are more than one strings in T that have the longest prefix match with x. In this case, the function must return the “closest” one to x among the multiple candidates. By the closest string to x, we mean the string that comes right before/after x when all candidate strings and x were listed in increasing lexicographic order. For example, given the trie in the figure and x = 100010, the search will encounter an empty node. In this case, the matching candidates are 110001 and 111000 The closest to x is 110001, which comes right after x.
